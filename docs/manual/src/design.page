---
title: Design Overview
layout: default
tagline: Hooray for OmniGraffle!
index: 3
filters:
  - erb
  - links
  - examples
  - editorial
  - api
  - textile
---

h2. <%= page.config['title'] %>

<div id="auto-toc"></div>

This is an overview of the design of Redleaf, where it differs from the Redland library's API, along with links into the appropriate <?link Guided Tour ?> page that provides examples and covers the topic in greater detail.

h3. Redland Library Classes

The Redleaf classes follow the basic design of the "Redland":http://librdf.org/ library, from which it derives most of its underlying functionality, with a few changes. Here's the class layout borrowed from "The Design and Implementation of the Redland RDF Application Framework":http://www.dajobe.org/2001/02/redland/redland.html#figure1:

p(diagram). !images/redland-classes.png(Redland Classes)!

p(caption). The classes that make up the Redland library.

h3. Redleaf Library Classes

If you're familiar with the Redland library, or with the SWIG-generated Ruby binding distributed alongside it, there are a few changes in Redleaf's API:

p(diagram). !images/redleaf-classes.png(Redleaf vs. Redland)!

p(caption). How Redland classes map to Redleaf ones.

h4. Nodes

The biggest change is that Redleaf is written with the idea that you will want to store regular Ruby objects in the Graph, not instances of a specialized "node" type that you have to wrap around every object before putting it in the graph.

To facilitate this, Redleaf provides a mapping of some of the more common Ruby classes to types in the "XML Schema namespace":http://www.w3.org/2001/XMLSchema, and a way to extend the conversion system with your own datatypes.

Blank node are represented in Ruby-space as Symbols and vice-versa; if you pass a Symbol as the subject or object of a triple, it will be converted to the equivalently-named blank node on the backend, and then mapped to the appropriate Symbol when it comes back out.

Type-conversion and blank nodes are covered in the <?link "Node Type System":tour/nodetypesystem.page ?> section.

h4. Other Changes

Beyond that, the changes are pretty minor. A simplified view of the classes you'll use in Redleaf looks something like this:

p(diagram). !images/design-overview.png(Redleaf Design Overview)!

p(caption). Redleaf classes.

* The Redland @Model@ class is called <?api Redleaf::Graph ?> (though there's an alias to @Redleaf::Model@ if you really want it). <?link Working With Graphs ?> in the guided tour covers most of what you need to know to get started.
* The Redland @Storage@ class is called <?api Redleaf::Store ?>, and is covered in the <?link Persistant Graphs ?> section of the tour.
* Most of the Redland "Support Classes", and the @Stream@, @Serializer@, and @Query@ classes don't have corollaries in Redleaf; they are used behind the scenes.
** The @Query@ class is used by the @#query@ method of the Graph class, but it does the conversion to the appropriate Query object for you from a String, and returns a <?api Redleaf::QueryResult ?> object that encapsulates the results of your query. This is covered by the <?link Querying a Graph ?> section of the tour.
** The Redland @URI@ class and the @Node@ class and its subclasses are all converted to and from Ruby objects as mentioned above (covered in <?link The Node Type System ?>).
** Iteration uses Ruby's @Enumerable@ interface, so there's no need for an explicit @Iterator@ class. Some fancy things you can do with iteration are highlighted in the <?link Graph Iteration ?> section.
** Serialization is all handled behind the scenes; see the <?link Serializing a Graph ?> section for more.

h3. Higher-Level Abstractions

I've tried to make the basic library easy to use for people who just want to start playing with triples, and also expose as much of Redland's power as possible for people who are more familiar with it. There's still a ways to go in both regards, but Redleaf is also intended to be a way that you can integrate RDF into your class libraries without having to necessarily know or care about the particulars of Graphs and Stores, and it provides several _experimental_ higher-level utilities to help with this.

h4. Archetypes

_More about this when it's closer to being done_

