---
title: Working With Graphs
layout: default
index: 2
filters:
  - erb
  - links
  - examples
  - editorial
  - api
  - textile
example_prelude: |-
  require 'redleaf'
---

h2. <%= page.config['title'] %>

<div id="auto-toc"></div>

<?api Redleaf::Graph ?> is the workhorse of Redleaf, the thing which you use to actually *do stuff* with statements.

h3(#creating). Creating A Graph

You can create a simple in-memory graph via the usual Ruby constructor:

<?example { language: ruby, testable: true, caption: Create an empty graph} ?>
Redleaf::Graph.new  # => 
<?end?>

It accepts a _store_ argument, too, but that'll come up "a little later":#triplestores, so just create them without an argument for a bit.

Once you've created a new @Graph@, you're ready to add some statements to it.

h3(#adding). Adding Statements

There are several ways to add statements to a @Graph@: you can read data in from some pre-existing source, copy them from other graph objects, or create new statements yourself. You've probably already seen how to create statements in the chapter on <?link Statements ?>, so let's do that first.

h3(#generating). Generating Your Own Statements

The way to add statements to a @Graph@ is via its @#append@ method:

<?example { language: ruby, caption: "Appending with #append", testable: true } ?>
include Redleaf::Constants::CommonNamespaces

myfoaf = Redleaf::Namespace.new( 'http://deveiate.org/foaf.xml#' )
st1 = Redleaf::Statement.new( myfoaf[:me], RDF[:type], FOAF[:Person] )
st2 = Redleaf::Statement.new( myfoaf[:me], FOAF[:name], "Michael Granger" )
st3 = Redleaf::Statement.new( myfoaf[:me], FOAF[:homepage], URI('http://deveiate.org/') )

graph = Redleaf::Graph.new
graph.append( st1, st2, st3 )
# => 
<?end?>

The append method is also known as the @#<<@ operator, and because it returns the receiving object, you can chain as many statements together as you want. The above example could be written like this instead:

<?example { language: ruby, caption: "Appending with the << operator", testable: true } ?>
include Redleaf::Constants::CommonNamespaces

myfoaf = Redleaf::Namespace.new( 'http://deveiate.org/foaf.xml#' )

graph = Redleaf::Graph.new
graph <<
	Redleaf::Statement.new( myfoaf[:me], RDF[:type], FOAF[:Person] ) <<
	Redleaf::Statement.new( myfoaf[:me], FOAF[:name], "Michael Granger" ) <<
	Redleaf::Statement.new( myfoaf[:me], FOAF[:homepage], URI('http://deveiate.org/') )

graph
# => 
<?end?>

h4. Appending With Syntax Shortcuts

The @#append@ method (and its sidekick the @#<<@ operator) also support several shortcut syntaxes so you don't have to do all those @Redleaf::Statement.new@ calls. If you want to append one or more simple statements, you can just send in three-element Arrays instead of <?api Redleaf::Statement ?> objects, and they'll be converted on the fly:

<?example { language: ruby, caption: "Appending triples as Arrays", testable: true } ?>
graph = Redleaf::Graph.new
exstaff = Redleaf::Namespace[ 'http://www.example.org/staffid/' ]
exterms = Redleaf::Namespace[ 'http://www.example.org/terms/' ]

graph <<
	[ exstaff["85740"],  exterms[:address],    :johnaddress ] <<
	[ :johnaddress,      exterms[:street],     "1501 Grant Avenue" ] <<
	[ :johnaddress,      exterms[:city],       "Bedford" ] <<
	[ :johnaddress,      exterms[:state],      "Massachusetts" ] <<
	[ :johnaddress,      exterms[:postalCode], "01730" ]

graph
# =>
<?end?>

h4. The @Redleaf::Graph#load@ Method

Chances are you'll quickly grow bored of inserting all those example statements, and will want to load a useful set of triples to work with. Redleaf can load statements from remote resources via the @Redleaf::Graph#load@ method:

<?example { language: ruby, caption: "Loading some statements from a URI", testable: true } ?>
graph = Redleaf::Graph.new
graph.load( 'http://deveiate.org/foaf.xml' )  # => 
graph
# => 
<?end?>


(Redland provides its own IO functions, handles all kinds of URI schemes, etc. Also cover the various serialization formats, and what Redland does by default)

h4. Reading RDF Data From Disk

If you have some kind of serialized RDF data in a local file, you can load it from disk by passing either a path or a @file@ URI to @#load@:

<?example { language: ruby, caption: "Appending triples as Arrays", testable: true } ?>
graph = Redleaf::Graph.new
graph.load( 'file:spec/data/mgranger-foaf.xml' )
graph
# =>
<?end?>

Now that you can load statements into a @Graph@, you're probably wondering how you can go about finding them again. Have no fear, you can ask a graph to give you back your statements in a number of ways.

h4. Loading RDF Data From A String

If you have some RDF data in a String and need to be able to load it directly, you can do so with a <?api Redleaf::Parser ?>. Say we have some RDF data in  "Turtle":http://www.dajobe.org/2004/01/turtle/ format:

<?example { language: ruby, caption: "Appending triples as Arrays", testable: true } ?>
require 'redleaf/parser/turtle'

baseuri = URI('http://www.example.org/')
a_string = <<EOF
@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix dc:      <http://purl.org/dc/elements/1.1/#>.
@prefix exterms: <http://www.example.org/terms/>.

<http://www.w3.org/TR/rdf-syntax-grammar> 
    dc:title "RDF/XML Syntax Specification (Revised)";
    exterm:editor [
        exterms:fullName "Dave Beckett";
        exterms:homePage <http://purl.org/net/dajobe/>.
    ].
EOF

parser = Redleaf::TurtleParser.new
parser.parse( a_string, baseuri )
# =>
<?end?>

You can read more about parsers in the <?link Parsing RDF ?> chapter.

h3(#searching). Searching A Graph

* #[]
* @#each_statement@ (aka @#each@)
* Topological Sorting (@#tsort@)
* The node-match iterators (@#subjects@, @#objects@, @#predicates@, @#predicates_entailing@, @#predicates_about@, etc.)


h3(#querying). Querying With SPARQL

* Querying with SPARQL
** #query
** Three kinds of Response object, depending on what kind of query it was
** Future goals
*** DSL
*** Sequel-like datasets

* RDQL


h3(#triplestores). Persistent Graphs via Redleaf::Store

* Stores can be used to persist graphs 
* You implicitly get a MemoryHashesStore whenever you use a Graph by itself
* You can upgrade at any time
* ...or you can start out with a store and get the associated Graph
* See the <?link Triple Stores ?> chapter for more specifics

h3(#serialization). Persistent Graphs via Serialization

* Serializers turn a graph into text in one of several different formats
** Which ones are built in, and how to find out which ones are supported
** How to access the serializer you want
** Generate an appropriate @Accept@ header for service content negotiation

