---
title: Working With Graphs
layout: default
index: 2
filters:
  - erb
  - links
  - examples
  - editorial
  - api
  - textile
example_prelude: |-
  require 'redleaf'
---

h2. <%= page.config['title'] %>

<div id="auto-toc"></div>

<?api Redleaf::Graph ?> is the workhorse of Redleaf, the thing which you use to actually *do stuff* with statements.

h3(#creating). Creating A Graph

You can create a simple in-memory graph via the usual Ruby constructor:

<?example { language: ruby, testable: true, caption: Create an empty graph} ?>
Redleaf::Graph.new  # => 
<?end?>

It accepts a _store_ argument, too, but that'll come up "a little later":#triplestores, so just create them without an argument for a bit.

Once you've created a new @Graph@, you're ready to add some statements to it.

h3(#adding). Adding Statements

There are several ways to add statements to a @Graph@: you can read data in from some pre-existing source, copy them from other graph objects, or create new statements yourself. You've probably already seen how to create statements in the chapter on <?link Statements ?>, so let's do that first.

The way to add existing statement objects to a @Graph@ is via its @#append@ method:

<?example { language: ruby, caption: "Appending with #append", testable: true } ?>
include Redleaf::Constants::CommonNamespaces

myfoaf = Redleaf::Namespace.new( 'http://deveiate.org/foaf.xml#' )
st1 = Redleaf::Statement.new( myfoaf[:me], RDF[:type], FOAF[:Person] )
st2 = Redleaf::Statement.new( myfoaf[:me], FOAF[:name], "Michael Granger" )
st3 = Redleaf::Statement.new( myfoaf[:me], FOAF[:homepage], URI('http://deveiate.org/') )

graph = Redleaf::Graph.new
graph.append( st1, st2, st3 )
# => 
<?end?>

The append method is also known as the @#<<@ operator, and because it returns the receiving object, you can chain as many statements together as you want. The above example could be written like this instead:

<?example { language: ruby, caption: "Appending with the << operator", testable: true } ?>
include Redleaf::Constants::CommonNamespaces

myfoaf = Redleaf::Namespace.new( 'http://deveiate.org/foaf.xml#' )

graph = Redleaf::Graph.new
graph <<
	Redleaf::Statement.new( myfoaf[:me], RDF[:type], FOAF[:Person] ) <<
	Redleaf::Statement.new( myfoaf[:me], FOAF[:name], "Michael Granger" ) <<
	Redleaf::Statement.new( myfoaf[:me], FOAF[:homepage], URI('http://deveiate.org/') )

graph.inspect
# => 
<?end?>

h4(#appending-shortcuts). Appending With Syntax Shortcuts

The @#append@ method (and its sidekick the @#<<@ operator) also support several shortcut syntaxes so you don't have to do all those @Redleaf::Statement.new@ calls. If you want to append one or more simple statements, you can just send in three-element Arrays instead of <?api Redleaf::Statement ?> objects, and they'll be converted on the fly:

<?example { language: ruby, caption: "Appending triples as Arrays", testable: true } ?>
graph = Redleaf::Graph.new
exstaff = Redleaf::Namespace[ 'http://www.example.org/staffid/' ]
exterms = Redleaf::Namespace[ 'http://www.example.org/terms/' ]

graph <<
	[ exstaff["85740"],  exterms[:address],    :johnaddress ] <<
	[ :johnaddress,      exterms[:street],     "1501 Grant Avenue" ] <<
	[ :johnaddress,      exterms[:city],       "Bedford" ] <<
	[ :johnaddress,      exterms[:state],      "Massachusetts" ] <<
	[ :johnaddress,      exterms[:postalCode], "01730" ]

graph.inspect
# =>
<?end?>

h4(#load). Loading Serialized RDF

Chances are you'll quickly grow bored of inserting all those example statements, and will want to load a useful set of triples to work with. You can load statements from serialized RDF via the @Redleaf::Graph#load@ method. It supports several different URL schemes, including @http@ and @file@, so you can load triples from a remote resource or from a local file:

<?example { language: ruby, caption: "Loading statements with <code>http</code> and <code>file</code> URLs", testable: false } ?>
graph = Redleaf::Graph.new
graph.load( 'http://deveiate.org/foaf.xml' )
graph.load( 'file:spec/data/mgranger-foaf.xml' )
<?end?>

h4. Loading RDF Data From A String

If you have some RDF data in a String and need to be able to load it directly, you can do so with a <?api Redleaf::Parser ?>. You can read more about parsers in the <?link Parsing RDF ?> chapter.

<?example { language: ruby, caption: "Appending triples as Arrays", testable: true } ?>
require 'redleaf/parser/turtle'

baseuri = URI('http://www.example.org/')
a_string = <<EOF
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix s:   <http://example.org/students/vocab#>.

<http://example.org/courses/6.001> s:students [
        a rdf:Bag;
        rdf:_1 <http://example.org/students/Amy>;
        rdf:_2 <http://example.org/students/Mohamed>;
        rdf:_3 <http://example.org/students/Johann>;
        rdf:_4 <http://example.org/students/Maria>;
        rdf:_5 <http://example.org/students/Phuong>.
    ].
EOF

parser = Redleaf::TurtleParser.new
parser.parse( a_string, baseuri )
# =>
<?end?>

You can read more about parsers in the <?link Parsing RDF ?> chapter.

h3(#searching). Searching A Graph

Now that you've loaded a bunch of statements into a @Graph@, you're probably wondering how you can go about finding them again.

h4(#indexop). The @#search@ Method

The easiest way is to use the @#search@ method, which takes a subject, a predicate, and an object that specify what triples to search for. Any of those three that are @nil@ will be treated as a wildcard, and will match any value for that part of the triples it finds.

<?example { language: ruby, caption: "Searching for triples.", testable: true } ?>
g = Redleaf::Graph.new
g.load( '' )

<?end?>


* @#each_statement@ (aka @#each@)
* Topological Sorting (@#tsort@)
* The node-match iterators (@#subjects@, @#objects@, @#predicates@, @#predicates_entailing@, @#predicates_about@, etc.)


h3(#querying). Querying With SPARQL

* Querying with SPARQL
** #query
** Three kinds of Response object, depending on what kind of query it was
** Future goals
*** DSL
*** Sequel-like datasets

* RDQL


h3(#triplestores). Persistent Graphs via Redleaf::Store

* Stores can be used to persist graphs 
* You implicitly get a MemoryHashesStore whenever you use a Graph by itself
* You can upgrade at any time
* ...or you can start out with a store and get the associated Graph
* See the <?link Triple Stores ?> chapter for more specifics

h3(#serialization). Persistent Graphs via Serialization

* Serializers turn a graph into text in one of several different formats
** Which ones are built in, and how to find out which ones are supported
** How to access the serializer you want
** Generate an appropriate @Accept@ header for service content negotiation

